{% extends "portal/base.html" %}
{% block title %}Панель{% endblock %}
{% block content %}
<h1 class="h4 mb-3">Панель управления</h1>

<div class="row g-3">
  <div class="col-sm-6 col-lg-3">
    <div class="card shadow-sm h-100">
      <div class="card-body">
        <div class="text-muted">Активных датчиков</div>
        <div class="display-6">{{ sensors_active_count }}</div>
      </div>
    </div>
  </div>
  <div class="col-sm-6 col-lg-3">
    <div class="card shadow-sm h-100">
      <div class="card-body">
        <div class="text-muted">Активных приводов</div>
        <div class="display-6">{{ actuators_active_count }}</div>
      </div>
    </div>
  </div>
  <div class="col-sm-6 col-lg-3">
    <div class="card shadow-sm h-100">
      <div class="card-body">
        <div class="text-muted">Построек</div>
        <div class="display-6">{{ facilities_count }}</div>
      </div>
    </div>
  </div>
  <div class="col-sm-6 col-lg-3">
    <div class="card shadow-sm h-100">
      <div class="card-body">
        <div class="text-muted">Правил</div>
        <div class="display-6">{{ rules_count }}</div>
      </div>
    </div>
  </div>
</div>

<hr class="my-4"/>

<h2 class="h5 mb-2">Последние оповещения</h2>
<div class="table-responsive">
  <table class="table table-sm table-hover align-middle">
    <thead>
      <tr>
        <th>Имя правила</th>
        <th>Дата срабатывания</th>
        <th>Уровень</th>
        <th>Сообщение</th>
      </tr>
    </thead>
    <tbody>
      {% for a in alerts_recent %}
        <tr>
          <td>{{ a.rule.name }}</td>
          <td>{{ a.started_at|date:"d.m.Y H:i:s" }}</td>
          <td>
            {% if a.rule.severity == 'critical' %}
              <span class="badge text-bg-danger">CRITICAL</span>
            {% elif a.rule.severity == 'warning' %}
              <span class="badge text-bg-warning">WARNING</span>
            {% else %}
              <span class="badge text-bg-info">INFO</span>
            {% endif %}
          </td>
          <td class="text-break">{{ a.message|default:"—" }}</td>
        </tr>
      {% empty %}
        <tr><td colspan="4" class="text-center text-muted">Пока нет оповещений</td></tr>
      {% endfor %}
    </tbody>
  </table>
</div>
<hr class="my-4"/>
<h2 class="h5 mb-2">Монитор датчиков</h2>

<div id="sensorTiles" class="row g-3"></div>

{{ active_sensors|json_script:"active-sensors-data" }}
{% endblock %}

{% block scripts %}
<script>
const TILE_HEIGHT = 160;
const REFRESH_MS  = 15000;
const RANGE_STR   = '30m';

function getRangeDurationMs(rangeStr){
  const m = /^(\d+)([smhd])$/.exec(rangeStr);
  if (!m) return 30*60000;
  const n = parseInt(m[1],10), u = m[2];
  const mult = { s:1000, m:60000, h:3600000, d:86400000 }[u] || 60000;
  return n * mult;
}
function pickTimeUnit(durMs){
  if (durMs <= 3*3600000)  return 'minute';
  if (durMs <= 12*3600000) return 'hour';
  return 'hour';
}
const DUR_MS = getRangeDurationMs(RANGE_STR);

const ACTIVE_SENSORS = JSON.parse(document.getElementById('active-sensors-data').textContent || '[]');

const tilesRoot = document.getElementById('sensorTiles');
const charts = new Map();
const timers = new Map();
const visible = new Map();

function makeTile(sensor){
  const col = document.createElement('div');
  col.className = 'col-12 col-md-6 col-lg-4';
  col.innerHTML = `
    <div class="card shadow-sm h-100">
      <div class="card-body p-2">
        <div class="d-flex justify-content-between align-items-baseline mb-1">
          <div class="small text-muted">${sensor['facility__name'] || '—'}</div>
          <div class="small">${sensor['unit__code'] || ''}</div>
        </div>
        <div class="fw-semibold text-truncate" title="${sensor.name}">${sensor.name}</div>
        <div class="mt-2" style="height:${TILE_HEIGHT}px">
          <canvas id="chart-${sensor.id}"></canvas>
        </div>
      </div>
    </div>`;
  tilesRoot.appendChild(col);

  const ctx = col.querySelector(`#chart-${sensor.id}`);
  const chart = new Chart(ctx, {
    type: 'line',
    data: { datasets: [{
      label: '',
      data: [],
      parsing: false,
      tension: 0.2,
      pointRadius: 0,
      borderWidth: 2
    }]},
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      interaction: { mode: 'nearest', intersect: false },
      scales: {
        x: {
          type: 'time',
          time: { tooltipFormat: 'dd.MM.yyyy HH:mm:ss', unit: pickTimeUnit(DUR_MS) },
          ticks: { source: 'auto' },
          bounds: 'ticks',
          min: Date.now() - DUR_MS,
          max: Date.now()
        },
        y: { beginAtZero: false }
      },
      plugins: {
        legend: { display: false },
        decimation: { enabled: true, algorithm: 'lttb', samples: 100 }
      }
    }
  });
  charts.set(sensor.id, chart);
  visible.set(sensor.id, true);
  return col;
}

function buildSeriesUrl(sensorId){
  const tmpl = `{% url 'portal:api_sensor_series' 0 %}`;
  return tmpl.replace('/0/', `/${sensorId}/`) + `?range=${RANGE_STR}`;
}

async function refreshTile(sensorId){
  if (!visible.get(sensorId)) return;
  const url = buildSeriesUrl(sensorId);
  try {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(resp.status + ' ' + (await resp.text()));
    const data = await resp.json();
    const rows = (data && data.series) ? data.series : [];
    const pts  = rows.map(p => ({ x: p.t, y: p.v }));
    const ch = charts.get(sensorId);
    if (!ch) return;

    ch.data.datasets[0].data = pts;

    const now = Date.now();
    ch.options.scales.x.time.unit = pickTimeUnit(DUR_MS);
    ch.options.scales.x.min = now - DUR_MS;
    ch.options.scales.x.max = now;

    if (pts.length) {
      const ys = pts.map(p => +p.y).filter(Number.isFinite);
      if (ys.length) {
        const ymin = Math.min(...ys), ymax = Math.max(...ys);
        const pad = (ymax - ymin) === 0 ? Math.max(1, Math.abs(ymax)*0.1) : (ymax - ymin)*0.1;
        ch.options.scales.y.min = ymin - pad;
        ch.options.scales.y.max = ymax + pad;
      } else {
        ch.options.scales.y.min = undefined;
        ch.options.scales.y.max = undefined;
      }
    }
    ch.update();
  } catch (e) {
    console.error('tile refresh failed', sensorId, e);
  }
}

function startAutoRefresh(sensorId){
  if (timers.has(sensorId)) return;
  const t = setInterval(() => refreshTile(sensorId), REFRESH_MS);
  timers.set(sensorId, t);
}

ACTIVE_SENSORS.forEach(s => {
  const tile = makeTile(s);
});

ACTIVE_SENSORS.forEach(s => {
  refreshTile(s.id);
  startAutoRefresh(s.id);
});

const io = new IntersectionObserver((entries) => {
  entries.forEach(e => {
    const canvas = e.target.querySelector('canvas');
    if (!canvas) return;
    const idMatch = canvas.id.match(/^chart-(\d+)/);
    if (!idMatch) return;
    const sensorId = parseInt(idMatch[1], 10);
    visible.set(sensorId, e.isIntersecting);
  });
}, { root: null, threshold: 0 });
document.querySelectorAll('#sensorTiles .card').forEach(card => io.observe(card));
</script>
{% endblock %}
